
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>opendp.smartnoise.synthesizers.mwem &#8212; OpenDP</title>
    
  <link href="../../../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    
  <link rel="preload" as="script" href="../../../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../index.html">
  <img src="../../../../_static/opendp-logo.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../quickstart/index.html">
  Quickstart
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../user/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../contrib/index.html">
  Contributor Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../smartnoise/index.html">
  SmartNoise
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../contact/index.html">
  Contact
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/opendp" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/opendp_org" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/opendp/opendp/discussions" rel="noopener" target="_blank" title="GitHub Discussions">
            <span><i class="far fa-comments"></i></span>
            <label class="sr-only">GitHub Discussions</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
<h6>Branches</h6>
<ul>
  <li><a href="mwem.html">latest</a></li>
</ul>


            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for opendp.smartnoise.synthesizers.mwem</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">opendp.smartnoise.synthesizers.base</span> <span class="kn">import</span> <span class="n">SDGYMBaseSynthesizer</span>


<div class="viewcode-block" id="MWEMSynthesizer"><a class="viewcode-back" href="../../../../smartnoise/api-reference/opendp.smartnoise.synthesizers.html#opendp.smartnoise.synthesizers.MWEMSynthesizer">[docs]</a><span class="k">class</span> <span class="nc">MWEMSynthesizer</span><span class="p">(</span><span class="n">SDGYMBaseSynthesizer</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="p">,</span>
        <span class="n">q_count</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
        <span class="n">iterations</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
        <span class="n">mult_weights_iterations</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">splits</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">split_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_bin_count</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
        <span class="n">custom_bin_count</span><span class="o">=</span><span class="p">{},</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         N-Dimensional numpy implementation of MWEM.</span>
<span class="sd">        (http://users.cms.caltech.edu/~katrina/papers/mwem-nips.pdf)</span>

<span class="sd">        From the paper:</span>
<span class="sd">        &quot;[MWEM is] a broadly applicable, simple, and easy-to-implement</span>
<span class="sd">        algorithm, capable of substantially improving the performance of</span>
<span class="sd">        linear queries on many realistic datasets...</span>
<span class="sd">        (circa 2012)...MWEM matches the best known and nearly</span>
<span class="sd">        optimal theoretical accuracy guarantees for differentially private</span>
<span class="sd">        data analysis with linear queries.&quot;</span>

<span class="sd">        Linear queries used for sampling in this implementation are</span>
<span class="sd">        random contiguous slices of the n-dimensional numpy array.</span>

<span class="sd">        :param q_count: Number of random queries in the pool to generate.</span>
<span class="sd">            Must be more than # of iterations, recommended ~10-15x iterations,</span>
<span class="sd">            defaults to 400</span>
<span class="sd">        :type q_count: int, optional</span>
<span class="sd">        :param epsilon: Privacy epsilon for DP, defaults to 3.0</span>
<span class="sd">        :type epsilon: float, optional</span>
<span class="sd">        :param iterations: Number of iterations of MWEM, defaults to 30</span>
<span class="sd">        :type iterations: int, optional</span>
<span class="sd">        :param mult_weights_iterations: Number of iterations of MW, per</span>
<span class="sd">            iteration of MWEM, defaults to 20</span>
<span class="sd">        :type mult_weights_iterations: int, optional</span>
<span class="sd">        :param splits: Allows you to specify feature dependence when creating</span>
<span class="sd">            internal histograms.</span>
<span class="sd">            Columns that are known to be dependent can be kept together.</span>
<span class="sd">            Example: splits=[[0,1],[2,3]] where</span>
<span class="sd">            columns 0 and 1 are dependent, columns 2 and 3 are dependent,</span>
<span class="sd">            and between groupings there is independence, defaults to []</span>
<span class="sd">        :type splits: list, optional</span>
<span class="sd">        :param split_factor: If splits not specified, can instead subdivide</span>
<span class="sd">            pseudo-randomly. For example, split_factor=3</span>
<span class="sd">            will make groupings of features of size 3 for the histograms.</span>
<span class="sd">            Note: this will likely make synthetic data worse.</span>
<span class="sd">            defaults to None</span>
<span class="sd">        :type split_factor: int, optional</span>
<span class="sd">        :param max_bin_count: MWEM is not good at continuous features, and</span>
<span class="sd">            is not purpose built for the feature. We can, however,</span>
<span class="sd">            fudge it by turning a continuous feature into a discrete feature with</span>
<span class="sd">            artificial binning. This is the maximum number</span>
<span class="sd">            of bins that MWEM will create. More bins leads to a huge slow down in</span>
<span class="sd">            MWEM due to dimensionality exploding the histogram</span>
<span class="sd">            size. Note, defaults to 500</span>
<span class="sd">        :type max_bin_count: int, optional</span>
<span class="sd">        :param custom_bin_count: If you have a specific bin assignment for</span>
<span class="sd">            continuous features (i.e. column 3 -&gt; 20 bins), specify it with</span>
<span class="sd">            a dict here, defaults to {}</span>
<span class="sd">        :type custom_bin_count: dict, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_count</span> <span class="o">=</span> <span class="n">q_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span> <span class="o">=</span> <span class="n">iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mult_weights_iterations</span> <span class="o">=</span> <span class="n">mult_weights_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synthetic_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_bins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splits</span> <span class="o">=</span> <span class="n">splits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_factor</span> <span class="o">=</span> <span class="n">split_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_bin_count</span> <span class="o">=</span> <span class="n">max_bin_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mins_maxes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_bin_count</span> <span class="o">=</span> <span class="n">custom_bin_count</span>

        <span class="c1"># Pandas check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pandas</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pd_cols</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pd_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Query trackers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_retries_exp_mechanism</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">SDGYMBaseSynthesizer</span><span class="o">.</span><span class="n">fit</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">categorical_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ordinal_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Follows sdgym schema to be compatible with their benchmark system.</span>

<span class="sd">        :param data: Dataset to use as basis for synthetic data</span>
<span class="sd">        :type data: np.ndarray</span>
<span class="sd">        :return: synthetic data, real data histograms</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pandas</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pd_cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pd_index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data must be a numpy array or pandas dataframe.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">splits</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">splits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_splits</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_factor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splits</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">splits</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">histograms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_histogram_from_data_attributes</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">histograms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_histogram_from_data_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">splits</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">histograms</span><span class="p">:</span>
            <span class="c1"># h[1] is dimensions for each histogram</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compose_arbitrary_slices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_count</span><span class="p">,</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># Run the algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synthetic_histograms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mwem</span><span class="p">()</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">SDGYMBaseSynthesizer</span><span class="o">.</span><span class="n">sample</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates samples from the histogram data.</span>
<span class="sd">        Follows sdgym schema to be compatible with their benchmark system.</span>
<span class="sd">        NOTE: We are sampleing from each split dimensional</span>
<span class="sd">        group as though they are *independent* from one another.</span>
<span class="sd">        We have essentially created len(splits) DP histograms as</span>
<span class="sd">        if they are separate databases, and combine the results into</span>
<span class="sd">        a single sample.</span>

<span class="sd">        :param samples: Number of samples to generate</span>
<span class="sd">        :type samples: int</span>
<span class="sd">        :return: N samples</span>
<span class="sd">        :rtype: list(np.ndarray)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">synthesized_columns</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">first</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">fake</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">split</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synthetic_histograms</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fake_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">fake</span><span class="p">)))</span>
            <span class="n">fake_distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">fake</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fake</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">fake_indices</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="n">fake_distribution</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)))</span>
            <span class="n">s_unraveled</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">s_unraveled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">fake</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="c1"># Here we make scale adjustments to match the original</span>
            <span class="c1"># data</span>
            <span class="n">np_unraveled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s_unraveled</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np_unraveled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">min_c</span><span class="p">,</span> <span class="n">max_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mins_maxes</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
                <span class="c1"># TODO: Deal with the 0 edge case when scaling</span>
                <span class="c1"># i.e. scale factor * 0th bin is 0,</span>
                <span class="c1"># but should still scale appropriately</span>
                <span class="n">np_unraveled</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np_unraveled</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
                <span class="n">np_unraveled</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np_unraveled</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">min_c</span>
            <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">synthesized_columns</span> <span class="o">=</span> <span class="n">np_unraveled</span>
                <span class="n">first</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">synthesized_columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">synthesized_columns</span><span class="p">,</span> <span class="n">np_unraveled</span><span class="p">))</span>
        <span class="c1"># Recombine the independent distributions into a single dataset</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">synthesized_columns</span>
        <span class="c1"># Reorder the columns to mirror their original order</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reorder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splits</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pandas</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">combined</span><span class="p">[:,</span> <span class="n">r</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pd_index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pd_cols</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">combined</span><span class="p">[:,</span> <span class="n">r</span><span class="p">]</span>

<div class="viewcode-block" id="MWEMSynthesizer.mwem"><a class="viewcode-back" href="../../../../smartnoise/api-reference/opendp.smartnoise.synthesizers.html#opendp.smartnoise.synthesizers.MWEMSynthesizer.mwem">[docs]</a>    <span class="k">def</span> <span class="nf">mwem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runner for the mwem algorithm.</span>
<span class="sd">        Initializes the synthetic histogram, and updates it</span>
<span class="sd">        for self.iterations using the exponential mechanism and</span>
<span class="sd">        multiplicative weights. Draws from the initialized query store</span>
<span class="sd">        for measurements.</span>

<span class="sd">        :return: synth_hist, self.histogram - synth_hist is the</span>
<span class="sd">            synthetic data histogram, self.histogram is original histo</span>
<span class="sd">        :rtype: np.ndarray, np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">histograms</span><span class="p">):</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">split</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">queries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">synth_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_a</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)</span>
            <span class="n">measurements</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># NOTE: Here we perform a privacy check,</span>
            <span class="c1"># because if the histogram dimensions are</span>
            <span class="c1"># greater than the iterations, this can be</span>
            <span class="c1"># a big privacy risk (the sample queries will</span>
            <span class="c1"># otherwise be able to match the actual</span>
            <span class="c1"># distribution)</span>
            <span class="c1"># This usually occurs with a split factor of 1,</span>
            <span class="c1"># so that each attribute is independent of the other</span>
            <span class="n">flat_dim</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>
                <span class="n">flat_dim</span> <span class="o">*=</span> <span class="n">j</span>
            <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">flat_dim</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Flattened dimensionality of synthetic histogram is less than&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; the number of iterations. This is a privacy risk.&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; Consider increasing your split_factor (especially if it is 1), &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;or decreasing the number of iterations. &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;Dim: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">flat_dim</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; Split: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">),</span>
                    <span class="ne">Warning</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">):</span>
                <span class="c1"># print(&quot;Iteration: &quot; + str(i))</span>
                <span class="n">qi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exponential_mechanism</span><span class="p">(</span>
                    <span class="n">hist</span><span class="p">,</span> <span class="n">synth_hist</span><span class="p">,</span> <span class="n">queries</span><span class="p">,</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">histograms</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="c1"># Make sure we get a different query to measure:</span>
                <span class="k">while</span> <span class="n">qi</span> <span class="ow">in</span> <span class="n">measurements</span><span class="p">:</span>
                    <span class="n">qi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exponential_mechanism</span><span class="p">(</span>
                        <span class="n">hist</span><span class="p">,</span> <span class="n">synth_hist</span><span class="p">,</span> <span class="n">queries</span><span class="p">,</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">histograms</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="c1"># NOTE: Add laplace noise here with budget</span>
                <span class="n">evals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">queries</span><span class="p">[</span><span class="n">qi</span><span class="p">],</span> <span class="n">hist</span><span class="p">)</span>
                <span class="n">lap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_laplace</span><span class="p">(</span>
                    <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">histograms</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="n">measurements</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span> <span class="o">+</span> <span class="n">lap</span>
                <span class="c1"># Improve approximation with Multiplicative Weights</span>
                <span class="n">synth_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiplicative_weights</span><span class="p">(</span>
                    <span class="n">synth_hist</span><span class="p">,</span> <span class="n">queries</span><span class="p">,</span> <span class="n">measurements</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mult_weights_iterations</span>
                <span class="p">)</span>
            <span class="n">a_values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">synth_hist</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="n">split</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">a_values</span></div>

    <span class="k">def</span> <span class="nf">_initialize_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">histogram</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a uniform distribution histogram from</span>
<span class="sd">        the given histogram with dimensions</span>

<span class="sd">        :param histogram: Reference histogram</span>
<span class="sd">        :type histogram: np.ndarray</span>
<span class="sd">        :param dimensions: Reference dimensions</span>
<span class="sd">        :type dimensions: np.ndarray</span>
<span class="sd">        :return: New histogram, uniformly distributed according to</span>
<span class="sd">        reference histogram</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: Could actually use a distribution from real data with some budget,</span>
        <span class="c1"># as opposed to using this uniform dist (would take epsilon as argument,</span>
        <span class="c1"># and detract from it)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">histogram</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="n">synth_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">histogram</span><span class="p">)</span>
        <span class="n">synth_hist</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">synth_hist</span>

    <span class="k">def</span> <span class="nf">_histogram_from_data_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">splits</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a histogram from given data</span>

<span class="sd">        :param data: Reference histogram</span>
<span class="sd">        :type data: np.ndarray</span>
<span class="sd">        :return: Histogram over given data, dimensions,</span>
<span class="sd">        bins created (output of np.histogramdd)</span>
<span class="sd">        :rtype: np.ndarray, np.shape, np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">histograms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="n">splits</span><span class="p">:</span>
            <span class="n">split_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">split</span><span class="p">]</span>
            <span class="n">mins_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">maxs_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dims_sizes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Transpose for column wise iteration</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split_data</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                <span class="n">min_c</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
                <span class="n">max_c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
                <span class="c1"># TODO: Make these noisy min/max</span>
                <span class="n">mins_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_c</span><span class="p">)</span>
                <span class="n">maxs_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_c</span><span class="p">)</span>
                <span class="c1"># Dimension size (number of bins)</span>
                <span class="n">bin_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_c</span> <span class="o">-</span> <span class="n">min_c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># Here we track the min and max for the column,</span>
                <span class="c1"># for sampling</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mins_maxes</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_c</span><span class="p">,</span> <span class="n">max_c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bin_count</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_bin_count</span><span class="p">:</span>
                    <span class="c1"># Note the limitations of MWEM here, specifically in the case of continuous data.</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Bin count &quot;</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">bin_count</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot; in column: &quot;</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="o">+</span> <span class="s2">&quot; exceeds max_bin_count, defaulting to: &quot;</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_bin_count</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot;. Is this a continuous variable?&quot;</span><span class="p">,</span>
                        <span class="ne">Warning</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">bin_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_bin_count</span>
                    <span class="c1"># We track a scaling factor per column, for sampling</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_c</span> <span class="o">-</span> <span class="n">min_c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_bin_count</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_bin_count</span><span class="p">:</span>
                    <span class="n">bin_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_bin_count</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">dims_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_count</span><span class="p">)</span>
            <span class="c1"># Produce an N,D dimensional histogram, where</span>
            <span class="c1"># we pre-specify the bin sizes to correspond with</span>
            <span class="c1"># our ranges above</span>
            <span class="n">histogram</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">split_data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">dims_sizes</span><span class="p">)</span>
            <span class="c1"># Return histogram, dimensions</span>
            <span class="n">histograms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">histogram</span><span class="p">,</span> <span class="n">dims_sizes</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">split</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">histograms</span>

    <span class="k">def</span> <span class="nf">_exponential_mechanism</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="n">synth_hist</span><span class="p">,</span> <span class="n">queries</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Refer to paper for in depth description of</span>
<span class="sd">        Exponential Mechanism.</span>
<span class="sd">        Parametrized with epsilon value epsilon/(2 * iterations)</span>

<span class="sd">        :param hist: Basis histogram</span>
<span class="sd">        :type hist: np.ndarray</span>
<span class="sd">        :param synth_hist: Synthetic histogram</span>
<span class="sd">        :type synth_hist: np.ndarray</span>
<span class="sd">        :param queries: Queries to draw from</span>
<span class="sd">        :type queries: list</span>
<span class="sd">        :param eps: Budget</span>
<span class="sd">        :type eps: float</span>
<span class="sd">        :return: # of errors</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">queries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hist</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">queries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">synth_hist</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">eps</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queries</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">maxi</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">errors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxi</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">))]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="n">e_s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)):</span>
            <span class="n">c</span> <span class="o">+=</span> <span class="n">errors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">*</span> <span class="n">e_s</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_multiplicative_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synth_hist</span><span class="p">,</span> <span class="n">queries</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="n">iterate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiplicative weights update algorithm,</span>
<span class="sd">        used to boost the synthetic data accuracy given measurements m.</span>
<span class="sd">        Run for iterate times</span>

<span class="sd">        :param synth_hist: Synthetic histogram</span>
<span class="sd">        :type synth_hist: np.ndarray</span>
<span class="sd">        :param queries: Queries to draw from</span>
<span class="sd">        :type queries: list</span>
<span class="sd">        :param m: Measurements taken from real data for each qi query</span>
<span class="sd">        :type m: dict</span>
<span class="sd">        :param hist: Basis histogram</span>
<span class="sd">        :type hist: np.ndarray</span>
<span class="sd">        :param iterate: Number of iterations to run mult weights</span>
<span class="sd">        :type iterate: iterate</span>
<span class="sd">        :return: synth_hist</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sum_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">synth_hist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterate</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">queries</span><span class="p">[</span><span class="n">qi</span><span class="p">],</span> <span class="n">synth_hist</span><span class="p">)</span>
                <span class="c1"># Perform the weights update</span>
                <span class="n">query_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_replace_in_place_slice</span><span class="p">(</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">synth_hist</span><span class="o">.</span><span class="n">copy</span><span class="p">()),</span> <span class="n">queries</span><span class="p">[</span><span class="n">qi</span><span class="p">])</span>

                <span class="c1"># Apply the update</span>
                <span class="n">a_multiplier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">query_update</span> <span class="o">*</span> <span class="n">error</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">sum_a</span><span class="p">))</span>
                <span class="n">a_multiplier</span><span class="p">[</span><span class="n">a_multiplier</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">synth_hist</span> <span class="o">=</span> <span class="n">synth_hist</span> <span class="o">*</span> <span class="n">a_multiplier</span>
                <span class="c1"># Normalize again</span>
                <span class="n">count_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">synth_hist</span><span class="p">)</span>
                <span class="n">synth_hist</span> <span class="o">=</span> <span class="n">synth_hist</span> <span class="o">*</span> <span class="p">(</span><span class="n">sum_a</span> <span class="o">/</span> <span class="n">count_a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">synth_hist</span>

    <span class="k">def</span> <span class="nf">_compose_arbitrary_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_s</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Here, dimensions is the shape of the histogram</span>
<span class="sd">        We want to return a list of length num_s, containing</span>
<span class="sd">        random slice objects, given the dimensions</span>
<span class="sd">        These are our linear queries</span>

<span class="sd">        :param num_s: Number of queries (slices) to generate</span>
<span class="sd">        :type num_s: int</span>
<span class="sd">        :param dimensions: Dimensions of histogram to be sliced</span>
<span class="sd">        :type dimensions: np.shape</span>
<span class="sd">        :return: Collection of random np.s_ (linear queries) for</span>
<span class="sd">        a dataset with dimensions</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slices_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># TODO: For analysis, generate a distribution of slice sizes,</span>
        <span class="c1"># by running the list of slices on a dimensional array</span>
        <span class="c1"># and plotting the bucket size</span>
        <span class="n">slices_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_s</span><span class="p">):</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
                <span class="c1"># Random linear sample, within dimensions</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">l_b</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="n">u_b</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">pre</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_b</span><span class="p">)</span>
                <span class="n">pre</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u_b</span><span class="p">)</span>
                <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span>
            <span class="c1"># Compose slices</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
                <span class="n">sl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">slices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">slices_list</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_slice</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a count query i.e. an arbitrary slice</span>

<span class="sd">        :param a_slice: Random slice within bounds of flattened data length</span>
<span class="sd">        :type a_slice: np.s_</span>
<span class="sd">        :param data: Data to evaluate from (synthetic dset)</span>
<span class="sd">        :type data: np.ndarray</span>
<span class="sd">        :return: Count from data within slice</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We want to count the number of objects in an</span>
        <span class="c1"># arbitrary slice of our collection</span>
        <span class="c1"># We use np.s_[arbitrary slice] as our queries</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">a_slice</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">e</span>

    <span class="k">def</span> <span class="nf">_binary_replace_in_place_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">a_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We want to create a binary copy of the data,</span>
<span class="sd">        so that we can easily perform our error multiplication</span>
<span class="sd">        in MW. Convenience function.</span>

<span class="sd">        :param data: Data</span>
<span class="sd">        :type data: np.ndarray</span>
<span class="sd">        :param a_slice: Slice</span>
<span class="sd">        :type a_slice: np.s_</span>
<span class="sd">        :return: Return data, where the range specified</span>
<span class="sd">        by a_slice is all 1s.</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">view</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">a_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">view</span>

    <span class="k">def</span> <span class="nf">_reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an array of dimensionality splits (column indices)</span>
<span class="sd">        returns the corresponding reorder array (indices to return</span>
<span class="sd">        columns to original order)</span>
<span class="sd">        Example:</span>
<span class="sd">        original = [[1, 2, 3, 4, 5, 6],</span>
<span class="sd">        [ 6,  7,  8,  9, 10, 11]]</span>

<span class="sd">        splits = [[1,3,4],[0,2,5]]</span>

<span class="sd">        mod_data = [[2 4 5 1 3 6]</span>
<span class="sd">                [ 7  9 10  6  8 11]]</span>

<span class="sd">        reorder = [3 0 4 1 2 5]</span>

<span class="sd">        :param splits: 2d list with splits (column indices)</span>
<span class="sd">        :type splits: array of arrays</span>
<span class="sd">        :return: 2d list with splits (column indices)</span>
<span class="sd">        :rtype: array of arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">splits</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">reordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flat</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">flat</span><span class="p">):</span>
            <span class="n">reordered</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">reordered</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If user specifies, do the work and figure out how to divide the dimensions</span>
<span class="sd">        into even splits to speed up MWEM</span>
<span class="sd">        Last split will contain leftovers &lt;= sizeof(factor)</span>

<span class="sd">        :param n_dim: Total # of dimensions</span>
<span class="sd">        :type n_dim: int</span>
<span class="sd">        :param factor: Desired size of the splits</span>
<span class="sd">        :type factor: int</span>
<span class="sd">        :return: Splits</span>
<span class="sd">        :rtype: np.array(np.array(),...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Columns indices</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_dim</span><span class="p">)</span>

        <span class="c1"># Split intelligently</span>
        <span class="n">fits</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">/</span> <span class="n">factor</span><span class="p">))</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span>
        <span class="n">even_inds</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="n">fits</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">/</span> <span class="n">factor</span><span class="p">),</span> <span class="n">factor</span><span class="p">))</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">even_inds</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="n">fits</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]):</span>
            <span class="n">s1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">fits</span><span class="p">:])</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l_val</span><span class="p">)</span> <span class="k">for</span> <span class="n">l_val</span> <span class="ow">in</span> <span class="n">s1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_laplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Laplace mechanism</span>

<span class="sd">        :param sigma: Laplace scale param sigma</span>
<span class="sd">        :type sigma: float</span>
<span class="sd">        :return: Random value from laplace distribution [-1,1]</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span></div>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../../../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2021.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.2.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>